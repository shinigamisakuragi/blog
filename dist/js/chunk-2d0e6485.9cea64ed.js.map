{"version":3,"sources":["webpack:///./src/views/js/debounce.vue?b523","webpack:///src/views/js/debounce.vue","webpack:///./src/views/js/debounce.vue?b5ee","webpack:///./src/views/js/debounce.vue"],"names":["render","_vm","this","_h","$createElement","_self","_c","_m","staticRenderFns","_v","attrs","component"],"mappings":"yHAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAsBH,EAAII,MAAMC,GAAO,OAAOL,EAAIM,GAAG,IACnGC,EAAkB,CAAC,WAAa,IAAIP,EAAIC,KAASC,EAAGF,EAAIG,eAAmBE,EAAGL,EAAII,MAAMC,IAAIH,EAAG,OAAOG,EAAG,MAAM,CAACA,EAAG,IAAI,CAACL,EAAIQ,GAAG,gFAAgFH,EAAG,IAAI,CAACL,EAAIQ,GAAG,4IAA4IH,EAAG,IAAI,CAACL,EAAIQ,GAAG,sJAAsJH,EAAG,IAAI,CAACL,EAAIQ,GAAG,qEAAqEH,EAAG,MAAM,CAACL,EAAIQ,GAAG,0yBAA0yBH,EAAG,IAAI,CAACL,EAAIQ,GAAG,oBAAoBH,EAAG,IAAI,CAACL,EAAIQ,GAAG,aAAaH,EAAG,QAAQ,CAACL,EAAIQ,GAAG,6FAA6FH,EAAG,MAAM,CAACL,EAAIQ,GAAG,2JAA2JH,EAAG,IAAI,CAACL,EAAIQ,GAAG,YAAYH,EAAG,MAAM,CAACL,EAAIQ,GAAG,qJAAqJH,EAAG,IAAI,CAACL,EAAIQ,GAAG,mBAAmBH,EAAG,MAAM,CAACL,EAAIQ,GAAG,2XAA2XH,EAAG,IAAI,CAACL,EAAIQ,GAAG,cAAcH,EAAG,MAAM,CAACL,EAAIQ,GAAG,wJAA0JH,EAAG,IAAI,CAACL,EAAIQ,GAAG,kEAAkEH,EAAG,IAAI,CAACL,EAAIQ,GAAG,WAAWH,EAAG,IAAI,CAACI,MAAM,CAAC,KAAO,4CAA4C,OAAS,WAAW,CAACT,EAAIQ,GAAG,+CAA+CR,EAAIQ,GAAG,6CCsGnzF,KCvGiW,I,YCO7VE,EAAY,eACd,EACAX,EACAQ,GACA,EACA,KACA,WACA,MAIa,aAAAG,E","file":"js/chunk-2d0e6485.9cea64ed.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('p',[_vm._v(\"DOM 事件里的 debounce 概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。\")]),_c('p',[_vm._v(\"在 JavaScript 中，debounce 函数所做的事情就是，强制一个函数在某个连续时间段内只执行一次，哪怕它本来会被调用多次。我们希望在用户停止某个操作一段时间之后才执行相应的监听函数，而不是在用户操作的过程当中，浏览器触发多少次事件，就执行多少次监听函数。 \")]),_c('p',[_vm._v(\"比如，在某个 3s 的时间段内连续地移动了鼠标，浏览器可能会触发几十（甚至几百）个 mousemove 事件，不使用 debounce 的话，监听函数就要执行这么多次；如果对监听函数使用 100ms 的“去弹跳”，那么浏览器只会执行一次这个监听函数，而且是在第 3.1s 的时候执行的。 \")]),_c('p',[_vm._v(\"现在，我们就来实现一个 debounce 函数，第一个参数是要“去弹跳”的回调函数 func，第二个是延迟的时间 delay。\")]),_c('pre',[_vm._v(\"        /**\\n        *\\n        * @param func {Function} 实际要执行的函数\\n        * @param delay {Number} 延迟时间，也就是阈值，单位是毫秒（ms）\\n        *\\n        * @return {Function} 返回一个“去弹跳”了的函数\\n        *\\n        */\\n        function debounce(func, delay) {\\n\\n          // 定时器，用来 setTimeout\\n          let timer;\\n\\n          // 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 func 函数\\n          return function () {\\n\\n            // 保存函数调用时的上下文和参数，传递给 func\\n            let self = this;\\n            let args = arguments;\\n\\n            // 每次这个返回的函数被调用，就清除定时器，以保证不执行 func\\n            clearTimeout(timer);\\n\\n            // 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作），\\n            // 再过 delay 毫秒就执行 func\\n            timer = setTimeout(function () {\\n              func.apply(self, args);\\n            }, delay);\\n          }\\n        }\\n    \")]),_c('p',[_vm._v(\"定义好方法之后我们这样使用它\")]),_c('p',[_vm._v(\"AJAX请求实例 \"),_c('small',[_vm._v(\"有一个类名为js-search-input的输入框，当用户输入的时候会发送请求。加入debounce函数之后会在300ms之后才会发送请求，这样可以有效的减少服务器压力。\")])]),_c('pre',[_vm._v(\"        $('.js-search-input').on('keyup', debounce(function(e) {\\n            // 发送 ajax 请求从服务端获取输入的关键字相关的数据显示在页面上，类似百度的搜索预测\\n        }, 300));\\n    \")]),_c('p',[_vm._v(\"页面缩放实例\")]),_c('pre',[_vm._v(\"        function resizeHandler() {\\n            // 监听resize事件做响应式设计\\n        }\\n\\n        window.onresize = debounce(resizeHandler, 300);\\n    \")]),_c('p',[_vm._v(\"页面滚动到元素可见位置用例\")]),_c('pre',[_vm._v(\"        function scrollHandler(){\\n          let win_pos = $(window).scrollTop();\\n          //也可以把元素位置初始化在页面加载完毕之时\\n          let element_height = $('.element').offset().top - $(window).height();\\n\\n          if (win_pos >= initCounterHeight) {\\n            console.log(\\\"scroll\\\");\\n          }\\n        };\\n\\n        $(window).scroll(debounce(scrollHandler, 100));\\n    \")]),_c('p',[_vm._v(\"改变窗口大小实例\")]),_c('pre',[_vm._v(\"        function resizeHandler() {\\n            console.log(\\\"resize\\\");\\n        }\\n\\n        window.onresize = throttle(resizeHandler, 300);\\n    \")]),_c('p',[_vm._v(\"debounce其实就是把触发非常频繁的事件合并成一次延迟执行，合理使用不仅可以减少服务器压力还能加快浏览器的渲染速度。\")]),_c('p',[_vm._v(\"可以访问这个 \"),_c('a',{attrs:{\"href\":\"http://demo.nimius.net/debounce_throttle/\",\"target\":\"_blank\"}},[_vm._v(\"http://demo.nimius.net/debounce_throttle/\")]),_vm._v(\" 来查看debounce、throttle和默认情况的事件监听效果。 \")])])}]\n\nexport { render, staticRenderFns }","<template>\n    <div>\n\n        <p>DOM 事件里的 debounce 概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。</p>\n\n        <p>在 JavaScript 中，debounce\n            函数所做的事情就是，强制一个函数在某个连续时间段内只执行一次，哪怕它本来会被调用多次。我们希望在用户停止某个操作一段时间之后才执行相应的监听函数，而不是在用户操作的过程当中，浏览器触发多少次事件，就执行多少次监听函数。\n        </p>\n\n        <p>比如，在某个 3s 的时间段内连续地移动了鼠标，浏览器可能会触发几十（甚至几百）个 mousemove 事件，不使用 debounce 的话，监听函数就要执行这么多次；如果对监听函数使用 100ms\n            的“去弹跳”，那么浏览器只会执行一次这个监听函数，而且是在第 3.1s 的时候执行的。\n        </p>\n\n        <p>现在，我们就来实现一个 debounce 函数，第一个参数是要“去弹跳”的回调函数 func，第二个是延迟的时间 delay。</p>\n\n        <pre>\n            /**\n            *\n            * @param func {Function} 实际要执行的函数\n            * @param delay {Number} 延迟时间，也就是阈值，单位是毫秒（ms）\n            *\n            * @return {Function} 返回一个“去弹跳”了的函数\n            *\n            */\n            function debounce(func, delay) {\n\n              // 定时器，用来 setTimeout\n              let timer;\n\n              // 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 func 函数\n              return function () {\n\n                // 保存函数调用时的上下文和参数，传递给 func\n                let self = this;\n                let args = arguments;\n\n                // 每次这个返回的函数被调用，就清除定时器，以保证不执行 func\n                clearTimeout(timer);\n\n                // 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作），\n                // 再过 delay 毫秒就执行 func\n                timer = setTimeout(function () {\n                  func.apply(self, args);\n                }, delay);\n              }\n            }\n        </pre>\n\n        <p>定义好方法之后我们这样使用它</p>\n\n        <p>AJAX请求实例\n            <small>有一个类名为js-search-input的输入框，当用户输入的时候会发送请求。加入debounce函数之后会在300ms之后才会发送请求，这样可以有效的减少服务器压力。</small>\n        </p>\n\n\n        <pre>\n            $('.js-search-input').on('keyup', debounce(function(e) {\n                // 发送 ajax 请求从服务端获取输入的关键字相关的数据显示在页面上，类似百度的搜索预测\n            }, 300));\n        </pre>\n\n        <p>页面缩放实例</p>\n\n        <pre>\n            function resizeHandler() {\n                // 监听resize事件做响应式设计\n            }\n\n            window.onresize = debounce(resizeHandler, 300);\n        </pre>\n\n        <p>页面滚动到元素可见位置用例</p>\n\n        <pre>\n            function scrollHandler(){\n              let win_pos = $(window).scrollTop();\n              //也可以把元素位置初始化在页面加载完毕之时\n              let element_height = $('.element').offset().top - $(window).height();\n\n              if (win_pos >= initCounterHeight) {\n                console.log(\"scroll\");\n              }\n            };\n\n            $(window).scroll(debounce(scrollHandler, 100));\n        </pre>\n\n        <p>改变窗口大小实例</p>\n        <pre>\n            function resizeHandler() {\n                console.log(\"resize\");\n            }\n\n            window.onresize = throttle(resizeHandler, 300);\n        </pre>\n\n        <p>debounce其实就是把触发非常频繁的事件合并成一次延迟执行，合理使用不仅可以减少服务器压力还能加快浏览器的渲染速度。</p>\n        <p>可以访问这个 <a href=\"http://demo.nimius.net/debounce_throttle/\" target=\"_blank\">http://demo.nimius.net/debounce_throttle/</a> 来查看debounce、throttle和默认情况的事件监听效果。\n        </p>\n    </div>\n</template>\n\n<script>\n    export default {}\n</script>\n\n<style scoped>\n\n</style>","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./debounce.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./debounce.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./debounce.vue?vue&type=template&id=7049ec97&scoped=true&\"\nimport script from \"./debounce.vue?vue&type=script&lang=js&\"\nexport * from \"./debounce.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"7049ec97\",\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}